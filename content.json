{"meta":{"title":"Vihi's Blog","subtitle":null,"description":null,"author":"Manphil","url":"https://manphil.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-19T11:17:27.535Z","updated":"2019-07-19T11:17:27.535Z","comments":true,"path":"404.html","permalink":"https://manphil.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"","date":"2019-05-13T01:06:38.232Z","updated":"2017-05-26T06:28:12.135Z","comments":true,"path":"baidu_verify_DCRZNaMqgK.html","permalink":"https://manphil.github.io/baidu_verify_DCRZNaMqgK.html","excerpt":"","text":"DCRZNaMqgK"},{"title":"","date":"2019-05-13T01:06:38.232Z","updated":"2017-05-26T06:28:37.041Z","comments":true,"path":"googlea389fb1203386194.html","permalink":"https://manphil.github.io/googlea389fb1203386194.html","excerpt":"","text":"google-site-verification: googlea389fb1203386194.html"},{"title":"关于","date":"2019-07-19T12:19:16.158Z","updated":"2019-07-19T12:19:16.158Z","comments":true,"path":"about/index.html","permalink":"https://manphil.github.io/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A postgraduate"},{"title":"归档","date":"2017-05-15T16:16:57.000Z","updated":"2017-05-17T08:02:46.351Z","comments":true,"path":"archives/index.html","permalink":"https://manphil.github.io/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-19T09:47:19.644Z","updated":"2019-07-19T09:47:19.644Z","comments":true,"path":"categories/index.html","permalink":"https://manphil.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-07-19T09:45:51.139Z","updated":"2019-07-19T09:45:51.139Z","comments":true,"path":"tags/index.html","permalink":"https://manphil.github.io/tags/index.html","excerpt":"","text":""},{"title":"message","date":"2017-05-15T16:17:27.000Z","updated":"2017-05-15T16:17:27.738Z","comments":true,"path":"message/index.html","permalink":"https://manphil.github.io/message/index.html","excerpt":"","text":""}],"posts":[{"title":"浅谈区块链共识","slug":"BlockchainConsensus","date":"2019-05-13T02:49:51.000Z","updated":"2019-05-13T07:09:03.216Z","comments":true,"path":"2019/05/13/BlockchainConsensus/","link":"","permalink":"https://manphil.github.io/2019/05/13/BlockchainConsensus/","excerpt":"区块链的一致性众所周知，区块链是一个链式结构的去中心化分布式账本，也是一个去中心化的分布式数据库，同时也是一个P2P (Peer-to-Peer)网络。区块链中的交易由P2P网络进行组织传播，每个节点均会承担网络路由、验证区块数据、传播区块数据、发现新节点等功能。区块链通过共识算法来选择节点负责新区块的生成和验证过程，从而保证区块链中的数据以及状态达到最终一致性。","text":"区块链的一致性众所周知，区块链是一个链式结构的去中心化分布式账本，也是一个去中心化的分布式数据库，同时也是一个P2P (Peer-to-Peer)网络。区块链中的交易由P2P网络进行组织传播，每个节点均会承担网络路由、验证区块数据、传播区块数据、发现新节点等功能。区块链通过共识算法来选择节点负责新区块的生成和验证过程，从而保证区块链中的数据以及状态达到最终一致性。 一般来说，在拜占庭环境中，如果区块链满足下列条件，即可认为区块链达到共识，数据保持了一致性。 有效性:如果区块链中所有的诚实节点都选择以同一个块为基础，都在该块之后进行扩展区块链，那么之后的新加入的诚实节点也将会以该块为头进行扩展。 一致性:如果一个诚实节点新生成并验证了一个块，那么其他诚实节点将更新其本地的区块链数据，并以新区块为头对区块链进行扩展。 活性:所有诚实节点所验证生成的区块最终都将会被全网确认，从而达成最终一致性。 全局顺序:当区块被验证之后，区块链中所有交易的顺序都将是一致的，均按照节点区块链视图中已验证区块的顺序。 一般按照权限的不同可将区块链分为：许可链 (Permissioned Blockchain)和非许可链 (Permissionless Blockchain)。联盟链中对不同的角色有着不同的权限，而私有链只对内提供权限，对外不可访问，因此联盟链和私有链属于许可链，包括超级账本 (HyperLedger Fabric)；而像我们常见的比特币和以太坊则属于非许可链，允许任何人加入其中。 不同类别的区块链有着不同的共识协议，许可链由于其本身有着严格的权限控制以及身份认证，所以许可链常采用拜占庭容错类算法来实现共识，如Ripple则采用了BFT共识算法，而超级账本则采用了PBFT共识算法。非许可链像比特币采用工作量证明 (POW)进行共识，以太坊则采用POW以及权益证明 (POS)作为共识算法。在文中的下一节中将详细介绍区块链中包括上述算法在内的各类共识算法。 区块链共识算法这一节将围绕着区块链的一致性展开，着重讨论区块链中的各类共识算法，包括Proof of Concept (PoX)、Practical Byzantine Fault Tolerance (PBFT)以及Raft等。 Proof of Concept在比特币系统中，中本聪提出了POW (Proof of Work)共识算法。POW定义了一个密码学难题，在创建一个新区块之前，矿工只有通过不停的穷举使得新区块的哈希满足这个密码学难题，从而才能使生成的区块被其他节点接受并确认。POW是一个以计算能力驱动的共识算法，为解决这个密码学难题，节点需要消耗巨大的算力。这也使得比特币能免受一些恶意节点的攻击，例如女巫攻击等。但另一方面，高算力消耗也将带来巨大的经济开销，例如电力消耗等。 随着比特币系统的成功，大部分区块链也采用了POW算法，同时也出现了大量类似的共识算法，包括： 权益证明 (Proof of Stake):权益证明使用伪随机数的方式指定持有货币的人为交易的验证者，并生成新的区块并接续在最长的链后面。当持有的货币数量越多，其打包交易生成区块的可能性越高。 内存证明 (Proof of Memory):该算法根据内存的大小来指定交易的验证者，并生成新的区块。和内存证明类似的还有存储证明 (Proof of Storage)，即使用存储空间的大小指定交易的验证者来生成区块。 时空证明 (Proof of Space-Time):时空证明根据各个节点中存储数据的时间来指定交易的验证和区块的生成者。矿工可以通过延长数据的存储时间来提升生成区块的可能性。 以上这些共识算法，可以统称为概念证明，即Proof of Concepts (PoX)。上述算法和POW类似，均是对系统中的某种概念或是资源，亦或是工作量亦或是权益以及存储等的证明。POX共识协议均需要网络中的节点非交互式地证明对系统中某些可测量资源的拥有或承诺，之后系统再根据这些证明来选举出唯一的矿工来生成区块，从而维护系统的一致性。 PoX共识算法的共识过程一般可以分为以下三个阶段： 初始化阶段 (生成随机种子或key):初始化阶段根据PoX规范向证明者和验证者提供在后续阶段中运行的必要信息，例如PoW中密码学难题所需要满足的条件。 执行阶段:执行阶段根据初始化阶段所设立的条件，对该条件尝试进行解决并提供相应的解决证明。 验证阶段:在验证阶段，验证者检查执行者给出的证明的正确性，该正确性基于证明者发布的信息并结合初始阶段所提出的条件进行确定。 在PoX中，难题的设计也需要考虑很多因素。由于非许可链是一个去中心化无权限的系统，相比与有权限控制的授权链，还需要避免难题的伪造以及防止共识过程被操控。除了需要保证难题的不可逆性，完整性，公平性之外，还需要考虑以下几个方面： 难题需要能够防止计算资源聚合的攻击。 难题的解决过程不应该破坏生态环境。 难题的结果应该要能提供有用的服务，例如正是某个实际场景中所需要的资源，而不是简单地算出一个哈希值，而这个哈希值对现实中的场景并无用处。 与此同时，也有一些满足上述设计要求的一些新型PoX共识算法被提出。为了使难题证明提供有用的服务，有用资源证明 (Proof of Useful Resources)被提出，用于解决PoW中算力资源的浪费问题。例如，练习证明 (Proof of Exercise)，用矩阵产品中的计算代替PoW中哈希的计算，共识中的难题从客户端中的计算任务中选取。 PBFT拜占庭容错算法 (Byzantine Fault Tolerant, BFT)是面向拜占庭将军问题的容错算法，解决如何在网络通信可靠但节点可能故障情况下达成共识的问题。然而，拜占庭问题的解决方案都存在复杂度过高的问题，直到PBFT (实用拜占庭容错算法)算法的提出。PBFT将拜占庭容错算法的复杂度从指数级降到了多项式级。 PBFT共识算法的基本过程如下： 首先通过轮换或随机算法选出某个节点作为主节点，每个主节点保持的阶段称为一个视图。 在某个视图中，客户端将请求发送给主节点，由主节点广播请求至其他副本节点。 所有节点处理完请求，并将处理结果返回给客户端。如果客户端收到超过1/3的不同节点的相同结果，则把此结果作为最终结果，即达成一致性。 PBFT共识过程主要包括以下几个阶段: 提案阶段、准备阶段以及提交确认阶段。提案和准备阶段确保同一个视图内请求发送的顺序正确，准备和提交阶段则确保在不同视图之间的确认请求时有序的。 PaxosPaxos是一个基于”两阶段提交”的共识算法，通过消息传递来消除分布式系统中的不确定状态。Paxos算法将节点分成三种角色，同一个节点在不同时刻可以担任不同角色： Proposer (提案者):提案者提出一个提案，等待其他节点同意将其作为最后的值。每个提案都有一个自增的提案号，一般由客户端作为提案者角色。 Acceptor (接收者):接收者负责对提案者提出的提案进行投票，一般由服务器担任该角色。 Learner (学习者):学习者获取最终被同意的结果，并广播给其他节点，不参与投票过程。学习者既可能客户端也可能是服务器。 在提案者发出提案后，Paxos算法会对提案进行两个阶段的提交，这两个阶段分别为准备 (Prepare)阶段和提交 (Commit)阶段 准备阶段:首先，提案者发送自己的提案的编号给多个接收者，接收者接收提案并保留收到过提案的最大编号以及接受的最大提案。如果收到提案号比目前保留的最大提案号还大，则返回自己已接受的提案值给提案者，更新当前最大提案号，表示不再接受比最大提案号还小的提案号。 提交阶段:提案者如果收到大多数的回复，则课准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，则使用自己的提案内容；如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。接收者收到”接受”消息后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。 一旦多数接受者接受了相同的提案值，则达成共识。 RaftRaft算法针对多个决策达成一致的问题，分解了Leader选举、日志复制和安全方面的考虑，通过约束减少了不确定性的状态空间。Raft算法包括三种角色：Leader (领导者)、Candidate (候选领导者)和Follower (跟随者)，算法通过选举一个全局的Leader来简化共识过程，Leader负责从客户端接收log，并转发到其他节点。Raft共识过程主要包括以下两个阶段： Leader选举:初始时，所有节点都是Follower，在随机超时后若未收到来自Leader或Candidate的消息，则所有节点变为Candidate，进行选举Leader。在选举阶段，得票超过一半的节点被选 Leader；若未选出，则随机超时后重新进行选举。 同步日志:Leader把系统中最新的日志分发给其他节点，并强制所有Follower更新这个记录，数据的同步是单向的。 总结在区块链系统中，共识过程是区块链中一个必不可少并且非常重要的一个环节，共识保证了系统中数据的一致性，同时有效的共识算法也能提升系统达成共识的速度，在公有链中PoX类共识算法例如PoW在一定程度上也能提升系统的安全性。共识算法也是区块链研究领域非常有前景的一个研究课题，尤其是如何将PoW类共识算法中的工作量进行有效的利用，而不仅仅是用来计算哈希值，例如可以把深度学习中的训练任务作为PoW中的工作量证明，这样既可以保证区块链的一致性同时网络中的算力也在深度学习的训练任务中得以利用。 参考文献 W. Wang, D. T. Hoang, Z. Xiong, D. Niyato, P. Wang, P. Hu, and Y. Wen, “A survey on consensus mechanisms and mining management in blockchain networks,” arXiv preprint arXiv:1805.02707, 2018.","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://manphil.github.io/categories/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://manphil.github.io/tags/Blockchain/"},{"name":"Consensus","slug":"Consensus","permalink":"https://manphil.github.io/tags/Consensus/"}]},{"title":"C++和Java中static的异同","slug":"C++和Java中static的异同","date":"2018-07-31T03:29:56.000Z","updated":"2018-07-31T04:16:43.186Z","comments":true,"path":"2018/07/31/C++和Java中static的异同/","link":"","permalink":"https://manphil.github.io/2018/07/31/C++和Java中static的异同/","excerpt":"本文主要比较C++和Java的static在类中的异同","text":"本文主要比较C++和Java的static在类中的异同 相同点 静态数据成员：类的所有对象都共享静态数据成员 静态方法：两者的静态方法都有以下限制 123方法中仅能访问静态方法方法中仅能访问静态成员方法中不能使用this以及super 都能直接用类名访问静态成员，但是写法稍有不同 123C++: 类名::成员名（数据成员或方法）Java: 类名.成员名 不同点 Java支持静态代码块, 用于支持类的初始化, 静态代码块中的代码仅在第一次新建对象时或第一次访问类的静态成员时才执行, 且仅执行一次, C++不支持以上特性 C++支持静态局部变量（即方法中的静态局部变量）, 而Java不支持, eg. 123456789class Test &#123; public static void main(String args[]) &#123; System.out.println(fun()); &#125; static int fun() &#123; static int x= 10; //Compiler Error: Static local variables are not allowed return x--; &#125;&#125; 参考Comparison of static keyword in C++ and Java","categories":[{"name":"C++杂谈","slug":"C-杂谈","permalink":"https://manphil.github.io/categories/C-杂谈/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://manphil.github.io/tags/C/"},{"name":"Java","slug":"Java","permalink":"https://manphil.github.io/tags/Java/"},{"name":"static","slug":"static","permalink":"https://manphil.github.io/tags/static/"}]},{"title":"使用Intellij编译Spark源码","slug":"使用Intellij编译Spark源码","date":"2018-04-01T12:38:47.000Z","updated":"2018-04-01T13:11:39.745Z","comments":true,"path":"2018/04/01/使用Intellij编译Spark源码/","link":"","permalink":"https://manphil.github.io/2018/04/01/使用Intellij编译Spark源码/","excerpt":"记录一下Intellij编译Spark的过程","text":"记录一下Intellij编译Spark的过程 使用Git从Github clone Spark源码 1git clone https://github.com/apache/spark.git 把Spark导入到Intellij中 File -&gt; New -&gt; Projects From Existing Sources -&gt; 选择clone的spark -&gt; Maven Project -&gt;…(接下来的操作使用默认即可) Building Spark 使用Intellij自带的maven进行编译： View -&gt; Tool Windows -&gt; Maven Projects 在打开的Maven面板中点击Execute Maven Goal小按钮，输入以下其中一个命令之一即可： 12345671、mvn clean package -Dmaven.test.skip=true2、mvn clean install -Dmaven.test.skip=true（发布到maven本地仓库中）3、mvn -DskipTests clean package4、mvn -DskipTests clean install (发布到maven本地仓库中) 可能是因为墙的原因，使用官方的 ./build/mvn -DskipTests clean package 命令一直都显示已连接，然后就没了==，不过使用sbt可以编译成功，在终端输入 ./build/sbt package 即可（需要梯子） 其他更多的编译命令可参考Spark官方文档Building Spark - Spark 2.3.0 Documentation 参考： https://spark.apache.org/docs/latest/building-spark.html https://blog.csdn.net/high2011/article/details/76651290","categories":[{"name":"Spark","slug":"Spark","permalink":"https://manphil.github.io/categories/Spark/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://manphil.github.io/tags/大数据/"},{"name":"Spark","slug":"Spark","permalink":"https://manphil.github.io/tags/Spark/"},{"name":"Intellij","slug":"Intellij","permalink":"https://manphil.github.io/tags/Intellij/"}]},{"title":"Deepin安装常用工具命令","slug":"Deepin安装常用工具命令","date":"2018-03-26T07:50:09.000Z","updated":"2018-03-26T08:17:43.597Z","comments":true,"path":"2018/03/26/Deepin安装常用工具命令/","link":"","permalink":"https://manphil.github.io/2018/03/26/Deepin安装常用工具命令/","excerpt":"安装gcc g++1sudo apt-get gcc g++ build-essential","text":"安装gcc g++1sudo apt-get gcc g++ build-essential 安装Java 为了使Deepin能够使用ppa源，需要先安装以下依赖 123sudo apt-get install python-software-propertiessudo apt-get install software-properties-commonsudo apt-get update 现在可以使用add-apt-repository命令添加ppa源了 12sudo add-apt-repository ppa:webupd8team/java sudo apt-get update 最后使用以下命令即可安装Java 12sudo apt-get install oracle-java9-installersudo update-java-alternatives -s java-9-oracle //这条命令是设置Java9为默认Java版本 安装git 下载Git 1sudo apt-get install git 设置用户名和邮箱 12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot; 生成key 12ssh-keygen -t rsa// 按三次回车默认即可 把/home/username/.ssh下的id_rsa.pub中的内容复制进Github即可 安装nodejs以及npm12sudo apt-get install nodejssudo apt-get install npm","categories":[{"name":"Deepin","slug":"Deepin","permalink":"https://manphil.github.io/categories/Deepin/"}],"tags":[]},{"title":"scala函数定义","slug":"scala函数定义","date":"2018-03-23T09:04:11.000Z","updated":"2018-03-23T09:43:56.139Z","comments":true,"path":"2018/03/23/scala函数定义/","link":"","permalink":"https://manphil.github.io/2018/03/23/scala函数定义/","excerpt":"总结了一下Scala中常见的几种函数定义方式","text":"总结了一下Scala中常见的几种函数定义方式 最原始的方式 123def add(a:Int, b:Int):Int = &#123; return a+b&#125; 进一步简化，首先Scala中不推荐使用return（默认返回最后一个表达式的值)，而且Scala可以省略返回值的类型。 简化的定义方式 1def add(a:Int, b:Int) = a + b 使用Lambda表达式定义 123val add : (Int, Int) =&gt; Int = (a, b) =&gt; a + b或val add = (a:Int, b:Int) =&gt; a + b 单参数1val fun:Int=&gt;String = p =&gt; &quot;The value of p is &quot; + p.toString() Note:定义函数时，如果没有写返回值类型，函数体前的“=”可以省略，如果显示声明了返回值类型，就必须要有“=”,eg.123456789//没有写返回值类型，省略等号def fun() &#123; println(&quot;Hello World~&quot;)&#125;//有返回值类型，等号必须写def fun():String = &#123; &quot;Hello&quot; + &quot;~World~&quot;&#125;","categories":[{"name":"Scala","slug":"Scala","permalink":"https://manphil.github.io/categories/Scala/"}],"tags":[{"name":"Scala","slug":"Scala","permalink":"https://manphil.github.io/tags/Scala/"}]},{"title":"Redis的使用","slug":"Redis的使用","date":"2017-10-02T07:55:01.000Z","updated":"2017-10-02T10:13:33.799Z","comments":true,"path":"2017/10/02/Redis的使用/","link":"","permalink":"https://manphil.github.io/2017/10/02/Redis的使用/","excerpt":"","text":"启动（Windows下） 在Resid目录下打开终端，输入redis-server.exe redis.windows.conf命令即可开启Redis 打开一个新的终端，输入redis-cli.exe进入Redis的命令交互界面 出现Creating Server TCP listening socket 127.0.0.1:6379: bind: No error错误说明Redis已经启动，直接输入redis-cli.exe进行使用，或按以下步骤解决： redis-cli.exe shutdown exit redis-server.exe redis.windows.conf","categories":[{"name":"Redis","slug":"Redis","permalink":"https://manphil.github.io/categories/Redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://manphil.github.io/tags/数据库/"},{"name":"NoSql","slug":"NoSql","permalink":"https://manphil.github.io/tags/NoSql/"},{"name":"Redis","slug":"Redis","permalink":"https://manphil.github.io/tags/Redis/"}]},{"title":"笔试总结","slug":"笔试总结","date":"2017-09-07T10:25:58.000Z","updated":"2017-09-07T10:25:58.506Z","comments":true,"path":"2017/09/07/笔试总结/","link":"","permalink":"https://manphil.github.io/2017/09/07/笔试总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"面试总结","slug":"面试总结","date":"2017-09-07T10:25:44.000Z","updated":"2017-09-07T16:01:18.662Z","comments":true,"path":"2017/09/07/面试总结/","link":"","permalink":"https://manphil.github.io/2017/09/07/面试总结/","excerpt":"2017-9-7 华为面试技术相关 系统的模块化划分？ 把一个系统分解小模块？如何分解。 如何更清晰地描述好自己写的算法？","text":"2017-9-7 华为面试技术相关 系统的模块化划分？ 把一个系统分解小模块？如何分解。 如何更清晰地描述好自己写的算法？ 非技术类问题 当有多个工作需要同时进行时，怎么规划自己的时间? 应该需要从多个方面去回答，分多种情况，比如当。。。时候，应该以。。。为重。 你觉得自己的自学能力如何？从那些方面可以体现出来，举个例子。 你还有什么问题想问的吗？ 这个一定要问，就算不知道该问什么，也要能扯出一些什么问题来。。但是要避免涉及到面试官的隐私之类的问题。","categories":[{"name":"胡说八道","slug":"胡说八道","permalink":"https://manphil.github.io/categories/胡说八道/"}],"tags":[{"name":"招聘","slug":"招聘","permalink":"https://manphil.github.io/tags/招聘/"},{"name":"面试","slug":"面试","permalink":"https://manphil.github.io/tags/面试/"}]},{"title":"收藏夹","slug":"收藏控","date":"2017-07-06T06:11:21.000Z","updated":"2017-08-05T00:49:47.755Z","comments":true,"path":"2017/07/06/收藏控/","link":"","permalink":"https://manphil.github.io/2017/07/06/收藏控/","excerpt":"主要是一些平时收藏的网页，工具","text":"主要是一些平时收藏的网页，工具 编辑器Markdown Editor.md 富文本 bootstrap-wysiwyg : 嵌入简单 wangEditor UEditor JavaScript相关插件 SweetAlert : 一个美化的JS弹框，不依赖于JQuery distpicker : 一个jQuery的省市区三级联动的地址选择器","categories":[{"name":"collection","slug":"collection","permalink":"https://manphil.github.io/categories/collection/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://manphil.github.io/tags/工具/"},{"name":"网页","slug":"网页","permalink":"https://manphil.github.io/tags/网页/"}]},{"title":"SSM框架-使用MyBatis Generator自动生成代码","slug":"SSM框架-使用MyBatis-Generator自动生成代码","date":"2017-07-05T10:10:01.000Z","updated":"2017-07-06T06:40:53.378Z","comments":true,"path":"2017/07/05/SSM框架-使用MyBatis-Generator自动生成代码/","link":"","permalink":"https://manphil.github.io/2017/07/05/SSM框架-使用MyBatis-Generator自动生成代码/","excerpt":"MyBatis Generator下载 下载 MyBatis Generator 下载之后，解压，把jdbc以及MyBatis的包复制进lib文件夹中。 新建一个generatorConfig.xml文件","text":"MyBatis Generator下载 下载 MyBatis Generator 下载之后，解压，把jdbc以及MyBatis的包复制进lib文件夹中。 新建一个generatorConfig.xml文件 配置文件generatorConfig.xml配置文件如下12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- 数据库驱动--&gt; &lt;classPathEntry location=&quot;mysql-connector-java-5.1.42-bin.jar&quot;/&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost/test&quot; userId=&quot;root&quot; password=&quot;&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 实体类的包名以及生成路径--&gt; &lt;javaModelGenerator targetPackage=&quot;test.pojo&quot; targetProject=&quot;src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 配置文件包名以及生成路径--&gt; &lt;sqlMapGenerator targetPackage=&quot;test.mapper&quot; targetProject=&quot;src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成的mapper接口--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;test.mapper&quot; targetProject=&quot;src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt; &lt;!-- 要生成几个表就写几个table标签--&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 使用方法在lib目录下打开命令窗口（shift+鼠标右键，选择PowerShell）输入以下命令：1java -jar mybatis-generator-core-1.3.5.jar -configfile generatorConfig.xml -overwrite 执行命令之后将会在src目录下生成配置文件中包所对应的路径下的相关代码。","categories":[{"name":"Java","slug":"Java","permalink":"https://manphil.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://manphil.github.io/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://manphil.github.io/tags/SSM/"},{"name":"MyBatis Generator","slug":"MyBatis-Generator","permalink":"https://manphil.github.io/tags/MyBatis-Generator/"}]},{"title":"SSM框架搭建","slug":"SSM框架搭建","date":"2017-07-05T09:56:29.000Z","updated":"2017-07-05T10:00:38.839Z","comments":true,"path":"2017/07/05/SSM框架搭建/","link":"","permalink":"https://manphil.github.io/2017/07/05/SSM框架搭建/","excerpt":"","text":"先占个坑。。","categories":[{"name":"Java","slug":"Java","permalink":"https://manphil.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://manphil.github.io/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://manphil.github.io/tags/SSM/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://manphil.github.io/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"https://manphil.github.io/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://manphil.github.io/tags/Mybatis/"}]},{"title":"Markdown语法学习","slug":"Markdown语法学习","date":"2017-05-25T15:48:20.000Z","updated":"2017-05-25T15:55:20.128Z","comments":true,"path":"2017/05/25/Markdown语法学习/","link":"","permalink":"https://manphil.github.io/2017/05/25/Markdown语法学习/","excerpt":"标题1234# 一级标题(注意#和文字之间的空格）## 二级标题### 三级标题依此类推...","text":"标题1234# 一级标题(注意#和文字之间的空格）## 二级标题### 三级标题依此类推... 代码1231.反引号`之间插入代码2.三个反引号之间插入代码3.在code标签之间插入代码&lt;code&gt;&lt;/code&gt; 引用 这是一段引用markdown语法如下 12&gt; 这是一段引用&gt; markdown语法如下 链接超链接Google12[Google](www.google.com)&lt;a href=&quot;www.google.com&quot;&gt;Google&lt;/a&gt; markdown可以直接嵌入HTML标签,所以可以直接用HTML来写markdown。 图片链接12![图片](图片地址)&lt;img src=&quot;&quot;&gt; 列表无序列表 列表一 列表二 列表三 12345678910111213141516（注意-和文字之间的空格，下同）- 列表一- 列表二- 列表三或+ 列表一+ 列表一+ 列表二或* 列表二* 列表三* 列表三 有序列表 列表一 列表二 列表三 1231. 列表一2. 列表二3. 列表三 表格 表项1 表项2 表项3 1 2 3 4 5 6 7 8 9 12345表项1|表项2|表项3--:|:--:|:--1 | 2| 34 | 5| 67 | 8| 9 第二行的冒号用来表示对齐方式，冒号在左边表示靠左显示，两边都有冒号表示居中对齐 格式粗体和斜体粗体斜体粗斜体123**粗体***斜体****粗斜体*** 参考Markdown 语法说明 (简体中文版)","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://manphil.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://manphil.github.io/tags/Markdown/"},{"name":"博客","slug":"博客","permalink":"https://manphil.github.io/tags/博客/"}]}]}